/**
 * @description Determines the base URL for the application based on the environment.
 * If the application is running on GitHub Pages, it returns "/StudyPal_AI".
 * Otherwise, it returns "/", which is suitable for local development.
 * @returns {string} The base URL for the application.
 */
export const baseAppUrl = (() => {
    const isGHPages = (typeof process !== 'undefined' && process.env.GH_DEPLOY) || (typeof window !== 'undefined' && window.location.hostname.includes("github.io"))
    // For GitHub Pages
    if (isGHPages) {
        return "/StudyPal_AI";
    }

    // For local development (localhost or 127.0.0.1)
    return "/";
})();

/**
 * Generates a color based on the input string.
 * The color is generated by creating a hash from the string, converting the hash to a hex color code,
 * and then darkening the color if the user's system is in dark mode.
 *
 * @param {string} str - The input string to generate the color from.
 * @returns {string} A hex color code generated from the input string.
 */
export const generateColorFromString = (str: string): string => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }

    const baseColor = hash & 0x00FFFFFF;
    const hexColor = '#' + baseColor.toString(16).toUpperCase().padStart(6, '0');

    // Darken the color in dark mode without using hooks
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const color = isDarkMode ? darkenColor(hexColor) : hexColor;
    return color.substring(0, 7);
};

/**
 * Darkens a given hexadecimal color by a specified factor.
 *
 * @param hexColor The hexadecimal color string to darken (e.g., "#RRGGBB").
 * @param factor The factor by which to darken the color (0 to 1). Default is 0.2.
 * @returns A new hexadecimal color string that is darker than the original.
 */
const darkenColor = (hexColor: string, factor: number = 0.2): string => {
    const hex = hexColor.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    const newR = Math.max(0, Math.floor(r * (1 - factor)));
    const newG = Math.max(0, Math.floor(g * (1 - factor)));
    const newB = Math.max(0, Math.floor(b * (1 - factor)));

    const newHexR = newR.toString(16).padStart(2, '0');
    const newHexG = newG.toString(16).padStart(2, '0');
    const newHexB = newB.toString(16).padStart(2, '0');

    return `#${newHexR}${newHexG}${newHexB}`;
};

/**
 * Formats bytes into human readable format.
 *
 * @param bytes - The number of bytes.
 * @param decimals - The number of decimal places to use. Defaults to 1.
 * @returns A string representing the formatted bytes.
 */
export function formatBytes(bytes: number, decimals: number = 1): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

/**
 * Converts a Blob to a Base64 string.
 *
 * @param {Blob} blob - The Blob to convert.
 * @returns {Promise<string>} A promise that resolves with the Base64 string representation of the Blob.
 */
export const blobToBase64 = (blob: Blob): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result as string);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
};

/**
 * Converts a Base64 string to a Blob.
 * if the string is not a valid Base64 string, it returns a Blob with the string as text.
 *
 * @param {string} data - The Base64 string to convert.
 * @returns {Blob} The Blob representation of the Base64 string.
 */
export const tryBase64ToBlob = (data: string): Blob => {
    if (/^data:([a-zA-Z0-9\/+]+);base64,/.test(data)) {
        const byteCharacters = atob(data.split(',')[1]); // Remove the prefix before decoding
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: data.split(',')[0].split(':')[1].split(';')[0] });
    }
    
    return new Blob([data], { type: 'text/plain' });
}

/**
 * Converts an ArrayBuffer to a Base64 string.
 *
 * @param {ArrayBuffer} buffer - The ArrayBuffer to convert.
 * @returns {string} The Base64 string representation of the ArrayBuffer.
 */
export const arrayBufferToBase64 = (buffer: ArrayBuffer): string => {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
};